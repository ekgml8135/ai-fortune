<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI 2026 신년운세</title>
  <style>
    :root{
      --bg:#f9fafb; --card:#ffffff; --line:#e5e7eb; --muted:#6b7280;
      --accent:#ff7a00; --accentBg:#fff3e8; --text:#111827;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans KR",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      margin:0; padding:24px;
      color:var(--text);
    }
    .wrap{
      max-width: 920px;
      margin: 0 auto;
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 25px rgba(0,0,0,.06);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 14px; color:var(--muted); font-size:13px; line-height:1.45; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items: center;
      margin-top: 10px;
    }
    .datepack{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      flex: 1;
      min-width: 280px;
    }
    .datepack .sep{
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }
    input[type="text"]{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      font-size: 14px;
      background: #fff;
      outline: none;
    }
    input[type="text"]:focus{
      border-color: rgba(255,122,0,.55);
      box-shadow: 0 0 0 3px rgba(255,122,0,.12);
    }
    .y{ width: 120px; }
    .m,.d{ width: 84px; }

    button{
      padding: 10px 16px;
      border-radius: 10px;
      border: none;
      background: var(--accent);
      color: white;
      font-weight: 900;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active{ transform: translateY(1px); }
    .hint{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    .result{
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px solid var(--line);
      display:none;
    }
    .badge{
      display:inline-block;
      padding: 5px 10px;
      border-radius: 999px;
      background: var(--accentBg);
      color: var(--accent);
      font-size: 12px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 820px){
      .grid-2{ grid-template-columns: 1fr 1fr; }
    }
    .card{
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 14px 12px;
      background: #fff;
    }
    .card h2{ margin: 0 0 8px; font-size: 16px; }
    .card h3{ margin: 10px 0 6px; font-size: 14px; }
    .lead{ font-size: 14px; line-height: 1.55; margin: 6px 0 0; }
    .kvs{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom: 8px; }
    .kv{
      padding: 6px 10px;
      border-radius: 12px;
      background: #f3f4f6;
      font-size: 12px;
    }
    .kv b{ font-weight: 900; }

    .months{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    @media (min-width: 820px){
      .months{ grid-template-columns: 1fr 1fr; }
    }
    .month{
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fff;
    }
    .month .m-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      font-size: 13px;
      margin-bottom: 6px;
    }
    .pill{
      font-size: 11px;
      font-weight: 900;
      background: var(--accentBg);
      color: var(--accent);
      padding: 3px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }
    .month p{ margin:0; font-size: 13px; line-height: 1.45; }

    .foot{
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .err{
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #fecaca;
      background: #fff1f2;
      color: #991b1b;
      border-radius: 12px;
      display:none;
      font-size: 13px;
      line-height: 1.45;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AI로 보는 2026년 운세</h1>
    <p class="sub">생년월일을 입력하면 2026년 전체 운세(큰 흐름 + 분야별 + 월별 포인트)가 표시됩니다.</p>

    <div class="row">
      <div class="datepack" aria-label="생년월일 입력">
        <input id="year" class="y" type="text" inputmode="numeric" autocomplete="bday-year"
               placeholder="YYYY" maxlength="4" aria-label="출생 연도(4자리)" />
        <span class="sep">-</span>
        <input id="month" class="m" type="text" inputmode="numeric" autocomplete="bday-month"
               placeholder="MM" maxlength="2" aria-label="출생 월(2자리)" />
        <span class="sep">-</span>
        <input id="day" class="d" type="text" inputmode="numeric" autocomplete="bday-day"
               placeholder="DD" maxlength="2" aria-label="출생 일(2자리)" />
      </div>

      <button id="go" type="button">운세 보기</button>
    </div>

    <div class="hint">
      입력 팁: 연도 4자리 입력하면 자동으로 월로 이동하고, 월 2자리 입력하면 일로 이동합니다. 엔터 없이 입력만으로 진행됩니다.
      <br/>결과는 랜덤이 아니라, 같은 생년월일이면 항상 동일하게 나옵니다.
    </div>

    <div id="err" class="err"></div>
    <div id="out" class="result"></div>

    <div class="foot">
      ※ 재미로 가볍게 보는 콘텐츠입니다. 개인의 선택과 노력에 따라 결과는 달라질 수 있습니다.
    </div>
  </div>

<script>
/* -------------------- 입력 UX: 숫자만 + 자동 이동 + 0 패딩 -------------------- */
const elY = document.getElementById("year");
const elM = document.getElementById("month");
const elD = document.getElementById("day");
const elGo = document.getElementById("go");
const elErr = document.getElementById("err");
const elOut = document.getElementById("out");

function onlyDigits(s){ return (s || "").replace(/\D/g, ""); }

function setError(msg){
  if(!msg){
    elErr.style.display = "none";
    elErr.textContent = "";
    return;
  }
  elErr.style.display = "block";
  elErr.textContent = msg;
}

function pad2(nStr){
  const s = String(nStr);
  if(s.length === 0) return "";
  if(s.length === 1) return "0" + s;
  return s.slice(0,2);
}

function clampInt(v, min, max){
  const n = parseInt(v, 10);
  if(Number.isNaN(n)) return null;
  if(n < min) return min;
  if(n > max) return max;
  return n;
}

function daysInMonth(year, month){
  // month: 1~12
  return new Date(year, month, 0).getDate();
}

function normalizeMonth(){
  let m = onlyDigits(elM.value).slice(0,2);
  if(m.length === 0){ elM.value = ""; return; }
  if(m.length === 1){
    // 2자리 입력 완료 전엔 그대로 두되, 숫자만 유지
    elM.value = m;
    return;
  }
  // 2자리면 패딩/클램프
  const mi = clampInt(m, 1, 12);
  elM.value = String(mi).padStart(2, "0");
}

function normalizeDayFor(year, month){
  let d = onlyDigits(elD.value).slice(0,2);
  if(d.length === 0){ elD.value = ""; return; }
  if(d.length === 1){ elD.value = d; return; }
  const dim = daysInMonth(year, month);
  const di = clampInt(d, 1, dim);
  elD.value = String(di).padStart(2, "0");
}

function normalizeYear(){
  let y = onlyDigits(elY.value).slice(0,4);
  elY.value = y;
}

function autoAdvance(fromEl, maxLen, toEl){
  const v = onlyDigits(fromEl.value);
  if(v.length >= maxLen){
    // 정확히 maxLen만 남기기
    fromEl.value = v.slice(0, maxLen);
    if(toEl){
      toEl.focus();
      toEl.select?.();
    }
  }
}

elY.addEventListener("input", () => {
  normalizeYear();
  autoAdvance(elY, 4, elM);
});

elM.addEventListener("input", () => {
  elM.value = onlyDigits(elM.value).slice(0,2);
  autoAdvance(elM, 2, elD);
});

elD.addEventListener("input", () => {
  elD.value = onlyDigits(elD.value).slice(0,2);
  // 2자리면 자동으로 운세 실행(원하면 제거 가능)
  if(onlyDigits(elD.value).length === 2){
    showFortune();
  }
});

// 포커스 벗어날 때 보기 좋게 0 패딩 / 유효범위 보정
elM.addEventListener("blur", () => {
  normalizeMonth();
});
elD.addEventListener("blur", () => {
  const y = parseInt(elY.value, 10);
  const m = parseInt(elM.value, 10);
  if(!Number.isNaN(y) && !Number.isNaN(m)){
    normalizeMonth();
    normalizeDayFor(y, m);
  } else {
    // 연/월이 없으면 단순 패딩만
    elD.value = pad2(onlyDigits(elD.value).slice(0,2));
  }
});

// Enter 누르면 다음 칸으로 이동
function onEnterMove(e, next){
  if(e.key === "Enter"){
    e.preventDefault();
    if(next){ next.focus(); next.select?.(); }
    else { showFortune(); }
  }
}
elY.addEventListener("keydown", (e)=>onEnterMove(e, elM));
elM.addEventListener("keydown", (e)=>onEnterMove(e, elD));
elD.addEventListener("keydown", (e)=>onEnterMove(e, null));

// 버튼
elGo.addEventListener("click", showFortune);

/* -------------------- 띠/별자리 -------------------- */
const ZODIAC = ["쥐","소","호랑이","토끼","용","뱀","말","양","원숭이","닭","개","돼지"];

function chineseZodiac(year){
  const idx = (year - 1900) % 12;
  return ZODIAC[(idx + 12) % 12];
}

function westernSign(month, day){
  if ((month===3 && day>=21) || (month===4 && day<=19)) return "양자리";
  if ((month===4 && day>=20) || (month===5 && day<=20)) return "황소자리";
  if ((month===5 && day>=21) || (month===6 && day<=20)) return "쌍둥이자리";
  if ((month===6 && day>=21) || (month===7 && day<=22)) return "게자리";
  if ((month===7 && day>=23) || (month===8 && day<=22)) return "사자자리";
  if ((month===8 && day>=23) || (month===9 && day<=22)) return "처녀자리";
  if ((month===9 && day>=23) || (month===10 && day<=22)) return "천칭자리";
  if ((month===10 && day>=23) || (month===11 && day<=21)) return "전갈자리";
  if ((month===11 && day>=22) || (month===12 && day<=21)) return "사수자리";
  if ((month===12 && day>=22) || (month===1 && day<=19)) return "염소자리";
  if ((month===1 && day>=20) || (month===2 && day<=18)) return "물병자리";
  return "물고기자리";
}

/* -------------------- 결정적(고정) 시드: 연/월/일 전체 사용 --------------------
   - 띠/별자리가 같아도 생년월일이 다르면 시드가 달라서 결과가 달라짐
   - 같은 생년월일이면 항상 같은 결과
*/
function xorshift32(x){
  x >>>= 0;
  x ^= (x << 13) >>> 0;
  x ^= (x >>> 17) >>> 0;
  x ^= (x << 5) >>> 0;
  return x >>> 0;
}

function makeSeed(y,m,d){
  // 날짜를 32bit로 섞기
  let s = ((y & 0xffff) << 16) ^ ((m & 0xff) << 8) ^ (d & 0xff);
  s ^= 0x9e3779b9; // 상수 섞기
  s = xorshift32(s);
  s = xorshift32(s ^ (y * 2654435761 >>> 0));
  return s >>> 0;
}

function pick(arr, seed, salt){
  const v = xorshift32((seed ^ salt) >>> 0);
  return arr[v % arr.length];
}

function fillTemplate(tpl, k){
  return tpl.replaceAll("{k}", k);
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* -------------------- 문구 풀 -------------------- */
const YEAR_THEMES = [
  { title: "정리 후 도약", flow: "상반기에는 기준을 정리하고, 하반기에는 속도를 내는 흐름입니다." },
  { title: "속도 조절", flow: "빠르게 움직이되, 중요한 순간엔 한 번 더 점검하면 성과가 커집니다." },
  { title: "기본기 강화", flow: "눈에 띄는 한 방보다, 작은 습관이 누적되며 결과를 바꿉니다." },
  { title: "확장과 연결", flow: "사람과 정보의 연결이 기회를 만들고, 선택지가 넓어지는 해입니다." },
  { title: "선택과 집중", flow: "할 일을 줄일수록 완성도가 올라가고, 집중한 분야에서 빛이 납니다." },
  { title: "안정적 상승", flow: "큰 변동보다 안정적으로 올라갑니다. ‘지속’이 최고의 전략입니다." },
  { title: "전환점", flow: "작은 결단이 큰 전환을 만듭니다. ‘방향’이 ‘속도’보다 중요합니다." },
  { title: "회복과 리셋", flow: "무리했던 루틴을 정리하고 회복하는 흐름입니다. 몸과 마음의 템포를 맞춰보세요." }
];

const KEYWORDS = ["정리","도약","균형","집중","확장","안정","관계","루틴","결단","유연함","성장","회복","정착","전환","수확"];

const FIELD_TEMPLATES = {
  work: [
    "업무는 ‘{k}’이 관건입니다. 작은 기준을 세우면 반복 업무가 줄어듭니다.",
    "일에서는 ‘{k}’이 성과로 이어집니다. 시작은 빠르게, 마무리는 단단하게 잡아보세요.",
    "업무운은 ‘{k}’ 쪽이 유리합니다. 협업은 역할을 명확히 하면 속도가 붙습니다.",
    "올해 일은 ‘{k}’에 달려 있습니다. 한 번에 크게보다, 단계적으로 쌓는 편이 좋습니다.",
    "업무에서 ‘{k}’을 선택하면 실수가 줄고, 신뢰가 늘어납니다."
  ],
  money: [
    "돈은 ‘{k}’ 방식이 안전합니다. 큰 결정보다 관리와 분산이 유리합니다.",
    "금전운은 ‘{k}’이 핵심입니다. 지출 항목을 줄이면 여유가 생깁니다.",
    "재정은 ‘{k}’로 가면 편합니다. 수입보다 ‘새는 돈’부터 잡아보세요.",
    "돈에서는 ‘{k}’이 답입니다. 계획한 소비는 괜찮고, 즉흥은 줄일수록 좋아요.",
    "금전은 ‘{k}’이 잘 맞습니다. 고정비를 한 번 점검해보면 체감이 큽니다."
  ],
  love: [
    "연애/관계는 ‘{k}’이 포인트입니다. 표현은 짧게, 확인은 한 번 더 해보세요.",
    "관계운은 ‘{k}’에 달려 있습니다. 타이밍을 맞추면 일이 부드럽게 풀립니다.",
    "연애운은 ‘{k}’이 유리합니다. 말보다 ‘행동’이 신뢰를 만듭니다.",
    "관계는 ‘{k}’로 풀립니다. 기대치를 맞추면 오해가 크게 줄어듭니다.",
    "연애/관계는 ‘{k}’이 관건입니다. 감정이 올라올수록 한 박자 천천히 가세요."
  ],
  health: [
    "건강운은 ‘{k}’이 중요합니다. 수면과 리듬을 먼저 잡으면 체력이 따라옵니다.",
    "건강은 ‘{k}’로 관리하세요. 무리한 몰아치기보다 꾸준함이 이깁니다.",
    "올해 몸은 ‘{k}’가 답입니다. 작은 신호는 초기에 케어하는 편이 좋습니다.",
    "건강운은 ‘{k}’에 달려 있습니다. 식사 시간만 일정해도 컨디션이 안정됩니다.",
    "건강은 ‘{k}’ 중심으로. 움직임과 휴식의 균형을 맞추는 게 핵심입니다."
  ]
};

const MONTH_PILLS = ["준비","정리","가속","확장","정착","전환","재정비","상승","선택","수확","마무리","리셋"];

const MONTH_TEMPLATES = [
  "이번 달은 ‘{k}’에 집중하면 좋습니다. 작은 한 가지를 끝내는 게 포인트입니다.",
  "‘{k}’이 흐름을 바꿉니다. 일정은 넉넉하게 잡을수록 결과가 좋아요.",
  "‘{k}’이 기회를 부릅니다. 미뤄둔 정리가 의외의 도움을 줍니다.",
  "‘{k}’이 유리합니다. 새로운 시도는 작게 시작하면 부담이 줄어요.",
  "‘{k}’이 핵심입니다. 속도보다 방향을 먼저 맞추세요.",
  "‘{k}’이 잘 맞는 달입니다. 체크리스트로 실수를 줄이면 편해집니다.",
  "‘{k}’이 안정감을 줍니다. 반복 가능한 루틴을 만들면 체감이 큽니다."
];

/* -------------------- 운세 생성 -------------------- */
function buildMonthlyPoints(seed){
  const months = [];
  for (let i=1; i<=12; i++){
    const kw = pick(KEYWORDS, seed, 0x1000 + i);
    const pill = pick(MONTH_PILLS, seed, 0x2000 + i);
    const tpl = pick(MONTH_TEMPLATES, seed, 0x3000 + i);
    months.push({ month: i, pill, text: fillTemplate(tpl, kw) });
  }
  return months;
}

function buildYearFortune(y,m,d){
  const seed = makeSeed(y,m,d);

  const animal = chineseZodiac(y);
  const sign = westernSign(m,d);

  // 큰 흐름/키워드는 "띠+별자리"만으로 결정되지 않도록, seed(생년월일 전체) 기반
  const theme = pick(YEAR_THEMES, seed, 0x4000);
  const yearKeyword = pick(KEYWORDS, seed, 0x5000);

  const workK = pick(KEYWORDS, seed, 0x6001);
  const moneyK = pick(KEYWORDS, seed, 0x6002);
  const loveK = pick(KEYWORDS, seed, 0x6003);
  const healthK = pick(KEYWORDS, seed, 0x6004);

  const work = fillTemplate(pick(FIELD_TEMPLATES.work, seed, 0x7001), workK);
  const money = fillTemplate(pick(FIELD_TEMPLATES.money, seed, 0x7002), moneyK);
  const love = fillTemplate(pick(FIELD_TEMPLATES.love, seed, 0x7003), loveK);
  const health = fillTemplate(pick(FIELD_TEMPLATES.health, seed, 0x7004), healthK);

  const months = buildMonthlyPoints(seed);
  const bigFlow = `${theme.flow} 올해의 메인 키워드는 ‘${yearKeyword}’입니다.`;

  return { animal, sign, themeTitle: theme.title, bigFlow, work, money, love, health, months };
}

/* -------------------- 렌더 -------------------- */
function render(out, data){
  const monthsHtml = data.months.map(m =>
    `<div class="month">
      <div class="m-title">
        <span>${m.month}월</span>
        <span class="pill">${escapeHtml(m.pill)}</span>
      </div>
      <p>${escapeHtml(m.text)}</p>
    </div>`
  ).join("");

  out.innerHTML = `
    <div class="badge">${escapeHtml(data.animal)}띠 · ${escapeHtml(data.sign)}</div>

    <div class="grid grid-2">
      <div class="card">
        <h2>2026 큰 흐름</h2>
        <div class="kvs">
          <div class="kv"><b>테마</b> ${escapeHtml(data.themeTitle)}</div>
        </div>
        <p class="lead">${escapeHtml(data.bigFlow)}</p>
      </div>

      <div class="card">
        <h2>분야별 운세</h2>
        <h3>일</h3><p class="lead">${escapeHtml(data.work)}</p>
        <h3>돈</h3><p class="lead">${escapeHtml(data.money)}</p>
        <h3>연애/관계</h3><p class="lead">${escapeHtml(data.love)}</p>
        <h3>건강</h3><p class="lead">${escapeHtml(data.health)}</p>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>월별 포인트</h2>
      <div class="months">${monthsHtml}</div>
    </div>
  `;
}

/* -------------------- 유효성 검사 + 실행 -------------------- */
function parseInputs(){
  const yRaw = onlyDigits(elY.value).slice(0,4);
  const mRaw = onlyDigits(elM.value).slice(0,2);
  const dRaw = onlyDigits(elD.value).slice(0,2);

  if(yRaw.length !== 4) return { ok:false, msg:"연도(YYYY) 4자리를 입력해 주세요." };
  if(mRaw.length !== 2) return { ok:false, msg:"월(MM) 2자리를 입력해 주세요. (예: 04)" };
  if(dRaw.length !== 2) return { ok:false, msg:"일(DD) 2자리를 입력해 주세요. (예: 17)" };

  const y = parseInt(yRaw, 10);
  const m = parseInt(mRaw, 10);
  if(!(y >= 1900 && y <= 2026)) return { ok:false, msg:"연도는 1900~2026 범위로 입력해 주세요." };
  if(!(m >= 1 && m <= 12)) return { ok:false, msg:"월은 01~12 범위로 입력해 주세요." };

  const dim = daysInMonth(y, m);
  const d = parseInt(dRaw, 10);
  if(!(d >= 1 && d <= dim)) return { ok:false, msg:`일은 해당 월의 01~${String(dim).padStart(2,"0")} 범위로 입력해 주세요.` };

  // 보기 좋게 0 패딩 반영
  elY.value = String(y);
  elM.value = String(m).padStart(2,"0");
  elD.value = String(d).padStart(2,"0");

  return { ok:true, y, m, d };
}

function showFortune(){
  setError("");

  const p = parseInputs();
  if(!p.ok){
    setError(p.msg);
    elOut.style.display = "none";
    return;
  }

  const data = buildYearFortune(p.y, p.m, p.d);
  elOut.style.display = "block";
  render(elOut, data);
}

/* -------------------- 페이지 로드시 연도에 포커스 -------------------- */
window.addEventListener("load", () => {
  elY.focus();
});
</script>
</body>
</html>
