<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI 2026 신년운세</title>
  <style>
    :root{
      --bg:#f9fafb; --card:#ffffff; --line:#e5e7eb; --muted:#6b7280;
      --accent:#ff7a00; --accentBg:#fff3e8; --text:#111827;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans KR",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      margin:0; padding:24px;
      color:var(--text);
    }
    .wrap{
      max-width: 960px;
      margin: 0 auto;
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 25px rgba(0,0,0,.06);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 14px; color:var(--muted); font-size:13px; line-height:1.45; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items: center;
      margin-top: 10px;
    }
    .datepack{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      flex: 1;
      min-width: 280px;
    }
    .datepack .sep{
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }
    input[type="text"]{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      font-size: 14px;
      background: #fff;
      outline: none;
    }
    input[type="text"]:focus{
      border-color: rgba(255,122,0,.55);
      box-shadow: 0 0 0 3px rgba(255,122,0,.12);
    }
    .y{ width: 120px; }
    .m,.d{ width: 84px; }

    button{
      padding: 10px 16px;
      border-radius: 10px;
      border: none;
      background: var(--accent);
      color: white;
      font-weight: 900;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active{ transform: translateY(1px); }
    .hint{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    .result{
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px solid var(--line);
      display:none;
    }
    .badge{
      display:inline-block;
      padding: 5px 10px;
      border-radius: 999px;
      background: var(--accentBg);
      color: var(--accent);
      font-size: 12px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 860px){
      .grid-2{ grid-template-columns: 1fr 1fr; }
    }
    .card{
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 14px 12px;
      background: #fff;
    }
    .card h2{ margin: 0 0 8px; font-size: 16px; }
    .card h3{ margin: 10px 0 6px; font-size: 14px; }
    .lead{ font-size: 14px; line-height: 1.55; margin: 6px 0 0; }
    .kvs{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom: 8px; }
    .kv{
      padding: 6px 10px;
      border-radius: 12px;
      background: #f3f4f6;
      font-size: 12px;
    }
    .kv b{ font-weight: 900; }

    .months{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    @media (min-width: 860px){
      .months{ grid-template-columns: 1fr 1fr; }
    }
    .month{
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fff;
    }
    .month .m-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      font-size: 13px;
      margin-bottom: 6px;
    }
    .pill{
      font-size: 11px;
      font-weight: 900;
      background: var(--accentBg);
      color: var(--accent);
      padding: 3px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }
    .month p{ margin:0; font-size: 13px; line-height: 1.45; }

    .foot{
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .err{
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #fecaca;
      background: #fff1f2;
      color: #991b1b;
      border-radius: 12px;
      display:none;
      font-size: 13px;
      line-height: 1.45;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AI로 보는 2026년 운세</h1>
    <p class="sub">생년월일을 입력하면 2026년 전체 운세(큰 흐름 + 분야별 + 월별 포인트)가 표시됩니다.</p>

    <div class="row">
      <div class="datepack" aria-label="생년월일 입력">
        <input id="year" class="y" type="text" inputmode="numeric" autocomplete="bday-year"
               placeholder="YYYY" maxlength="4" aria-label="출생 연도(4자리)" />
        <span class="sep">-</span>
        <input id="month" class="m" type="text" inputmode="numeric" autocomplete="bday-month"
               placeholder="MM" maxlength="2" aria-label="출생 월(2자리)" />
        <span class="sep">-</span>
        <input id="day" class="d" type="text" inputmode="numeric" autocomplete="bday-day"
               placeholder="DD" maxlength="2" aria-label="출생 일(2자리)" />
      </div>

      <button id="go" type="button">운세 보기</button>
    </div>

    <div class="hint">
      입력 팁: 연도 4자리 입력하면 자동으로 월로 이동하고, 월 2자리 입력하면 일로 이동합니다. 엔터 없이 입력만으로 진행됩니다.
      <br/>결과는 랜덤이 아니라, 같은 생년월일이면 항상 동일하게 나옵니다.
    </div>

    <div id="err" class="err"></div>
    <div id="out" class="result"></div>

    <div class="foot">
      ※ 재미로 가볍게 보는 콘텐츠입니다. 개인의 선택과 노력에 따라 결과는 달라질 수 있습니다.
    </div>
  </div>

<script>
/* ===================== 입력 UX: 숫자만 + 자동 이동 + 0 패딩 ===================== */
const elY = document.getElementById("year");
const elM = document.getElementById("month");
const elD = document.getElementById("day");
const elGo = document.getElementById("go");
const elErr = document.getElementById("err");
const elOut = document.getElementById("out");

function onlyDigits(s){ return (s || "").replace(/\D/g, ""); }

function setError(msg){
  if(!msg){
    elErr.style.display = "none";
    elErr.textContent = "";
    return;
  }
  elErr.style.display = "block";
  elErr.textContent = msg;
}

function clampInt(v, min, max){
  const n = parseInt(v, 10);
  if(Number.isNaN(n)) return null;
  if(n < min) return min;
  if(n > max) return max;
  return n;
}

function daysInMonth(year, month){
  return new Date(year, month, 0).getDate();
}

function normalizeYear(){
  let y = onlyDigits(elY.value).slice(0,4);
  elY.value = y;
}
function normalizeMonth(){
  let m = onlyDigits(elM.value).slice(0,2);
  if(m.length === 0){ elM.value = ""; return; }
  if(m.length === 1){ elM.value = m; return; }
  const mi = clampInt(m, 1, 12);
  elM.value = String(mi).padStart(2, "0");
}
function normalizeDayFor(year, month){
  let d = onlyDigits(elD.value).slice(0,2);
  if(d.length === 0){ elD.value = ""; return; }
  if(d.length === 1){ elD.value = d; return; }
  const dim = daysInMonth(year, month);
  const di = clampInt(d, 1, dim);
  elD.value = String(di).padStart(2, "0");
}

function autoAdvance(fromEl, maxLen, toEl){
  const v = onlyDigits(fromEl.value);
  if(v.length >= maxLen){
    fromEl.value = v.slice(0, maxLen);
    if(toEl){
      toEl.focus();
      toEl.select?.();
    }
  }
}

elY.addEventListener("input", () => { normalizeYear(); autoAdvance(elY, 4, elM); });
elM.addEventListener("input", () => { elM.value = onlyDigits(elM.value).slice(0,2); autoAdvance(elM, 2, elD); });
elD.addEventListener("input", () => {
  elD.value = onlyDigits(elD.value).slice(0,2);
  // 2자리 입력 완료 시 자동 실행
  if(onlyDigits(elD.value).length === 2){
    showFortune();
  }
});

elM.addEventListener("blur", () => normalizeMonth());
elD.addEventListener("blur", () => {
  const y = parseInt(elY.value, 10);
  const m = parseInt(elM.value, 10);
  if(!Number.isNaN(y) && !Number.isNaN(m)){
    normalizeMonth();
    normalizeDayFor(y, m);
  } else {
    elD.value = onlyDigits(elD.value).slice(0,2);
    if(elD.value.length === 1) elD.value = "0" + elD.value;
  }
});

function onEnterMove(e, next){
  if(e.key === "Enter"){
    e.preventDefault();
    if(next){ next.focus(); next.select?.(); }
    else { showFortune(); }
  }
}
elY.addEventListener("keydown", (e)=>onEnterMove(e, elM));
elM.addEventListener("keydown", (e)=>onEnterMove(e, elD));
elD.addEventListener("keydown", (e)=>onEnterMove(e, null));

elGo.addEventListener("click", showFortune);

window.addEventListener("load", () => elY.focus());

/* ===================== 띠/별자리 ===================== */
const ZODIAC = ["쥐","소","호랑이","토끼","용","뱀","말","양","원숭이","닭","개","돼지"];
function chineseZodiac(year){
  const idx = (year - 1900) % 12;
  return ZODIAC[(idx + 12) % 12];
}
function westernSign(month, day){
  if ((month===3 && day>=21) || (month===4 && day<=19)) return "양자리";
  if ((month===4 && day>=20) || (month===5 && day<=20)) return "황소자리";
  if ((month===5 && day>=21) || (month===6 && day<=20)) return "쌍둥이자리";
  if ((month===6 && day>=21) || (month===7 && day<=22)) return "게자리";
  if ((month===7 && day>=23) || (month===8 && day<=22)) return "사자자리";
  if ((month===8 && day>=23) || (month===9 && day<=22)) return "처녀자리";
  if ((month===9 && day>=23) || (month===10 && day<=22)) return "천칭자리";
  if ((month===10 && day>=23) || (month===11 && day<=21)) return "전갈자리";
  if ((month===11 && day>=22) || (month===12 && day<=21)) return "사수자리";
  if ((month===12 && day>=22) || (month===1 && day<=19)) return "염소자리";
  if ((month===1 && day>=20) || (month===2 && day<=18)) return "물병자리";
  return "물고기자리";
}

/* ===================== 결정적(고정) 시드 + 셔플 =====================
   - 생년월일(연/월/일 전체) 기반 → 같은 띠/별자리여도 결과가 달라짐
   - 같은 생년월일이면 항상 동일
*/
function xorshift32(x){
  x >>>= 0;
  x ^= (x << 13) >>> 0;
  x ^= (x >>> 17) >>> 0;
  x ^= (x << 5) >>> 0;
  return x >>> 0;
}
function makeSeed(y,m,d){
  let s = ((y & 0xffff) << 16) ^ ((m & 0xff) << 8) ^ (d & 0xff);
  s ^= 0x9e3779b9;
  s = xorshift32(s);
  s = xorshift32(s ^ (y * 2654435761 >>> 0));
  s = xorshift32(s ^ (m * 1597334677 >>> 0));
  s = xorshift32(s ^ (d * 3812015801 >>> 0));
  return s >>> 0;
}
function rnd01(seedObj){
  // seedObj: {v:number}
  seedObj.v = xorshift32(seedObj.v);
  return seedObj.v / 0x100000000; // [0,1)
}
function shuffleWithSeed(arr, seed){
  const a = arr.slice();
  const s = {v: seed >>> 0};
  for(let i=a.length-1; i>0; i--){
    const j = Math.floor(rnd01(s) * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function pickOne(arr, seed, salt){
  const s = xorshift32((seed ^ salt) >>> 0);
  return arr[s % arr.length];
}
function sampleUnique(arr, n, seed, salt){
  // 큰 풀에서 n개를 중복 없이
  const order = shuffleWithSeed(arr, xorshift32((seed ^ salt) >>> 0));
  return order.slice(0, Math.min(n, order.length));
}

function fill(t, vars){
  return t.replace(/\{(\w+)\}/g, (_,k)=> String(vars[k] ?? ""));
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* ===================== 콘텐츠 풀(다양성 강화) ===================== */
/**
 * 월별이 비슷해지는 이유:
 *  - 같은 문장 구조 반복
 *  - 같은 종류의 조언만 반복
 *
 * 해결:
 *  - 월별을 "유형(type)"으로 나누고
 *  - 유형별 문장 풀을 크게 만들고
 *  - 생년월일 시드로 '12개월 유형 배치 + 문장 선택'을 전부 다르게 만들기
 *  - 한 사람 안에서도 문장/태그가 최대한 겹치지 않도록 중복 제거
 */

// 큰 흐름(연간 테마)
const YEAR_THEMES = [
  { title: "정리 후 가속", flow: "상반기는 정리와 재배치, 하반기는 속도와 확장이 함께 옵니다." },
  { title: "선택과 집중", flow: "할 일을 줄일수록 결과가 커집니다. 방향을 잡으면 실행이 빨라집니다." },
  { title: "연결의 해", flow: "사람·정보·기회가 ‘연결’로 들어옵니다. 혼자보다 함께가 유리합니다." },
  { title: "기본기 강화", flow: "한 번의 큰 성과보다, 작은 습관이 누적되며 판이 바뀝니다." },
  { title: "전환점", flow: "작은 결단이 큰 전환을 만듭니다. ‘속도’보다 ‘방향’이 중요합니다." },
  { title: "회복과 리셋", flow: "무리했던 루틴을 정리하고 회복하는 흐름입니다. 템포를 맞추면 안정됩니다." },
  { title: "확장과 브랜딩", flow: "성과를 밖으로 보여주는 해입니다. 포지션을 정하면 기회가 따라옵니다." },
  { title: "안정적 상승", flow: "큰 변동보다 안정적인 상승입니다. 꾸준함이 가장 강한 전략입니다." }
];

// 분야별(일/돈/연애/건강) — 문장 풀 확장
const KEYWORDS = [
  "정리","도약","균형","집중","확장","안정","관계","루틴","결단","유연함","성장","회복",
  "정착","전환","수확","협상","속도","완성","정비","발견","선별","설득","실행","휴식"
];

const FIELD_TEMPLATES = {
  work: [
    "업무는 ‘{k}’이 관건입니다. 먼저 기준을 세우면 속도가 따라옵니다.",
    "일에서는 ‘{k}’이 성과로 이어집니다. 시작은 빠르게, 마무리는 단단하게 잡아보세요.",
    "업무운은 ‘{k}’ 쪽이 유리합니다. 협업은 역할을 명확히 하면 마찰이 줄어듭니다.",
    "올해 일은 ‘{k}’에 달려 있습니다. 한 번에 크게보다, 단계적으로 쌓는 편이 좋습니다.",
    "일에서 ‘{k}’을 선택하면 실수가 줄고, 신뢰가 늘어납니다.",
    "업무는 ‘{k}’을 기준으로 정리하면 편해집니다. 반복 작업을 자동화/템플릿화해 보세요.",
    "일은 ‘{k}’로 풀립니다. 중요한 건 ‘더 하기’가 아니라 ‘덜어내기’입니다."
  ],
  money: [
    "돈은 ‘{k}’ 방식이 안전합니다. 큰 결정보다 관리와 분산이 유리합니다.",
    "금전운은 ‘{k}’이 핵심입니다. 고정비를 한 번 점검해보면 체감이 큽니다.",
    "재정은 ‘{k}’로 가면 편합니다. 수입보다 ‘새는 돈’부터 잡아보세요.",
    "돈에서는 ‘{k}’이 답입니다. 계획한 소비는 괜찮고, 즉흥은 줄일수록 좋아요.",
    "금전은 ‘{k}’이 잘 맞습니다. ‘쓸 때 쓰기’보다 ‘지킬 때 지키기’가 중요합니다.",
    "돈은 ‘{k}’로 안정됩니다. 예산을 작게 나누면 지출이 덜 흔들립니다."
  ],
  love: [
    "연애/관계는 ‘{k}’이 포인트입니다. 표현은 짧게, 확인은 한 번 더 해보세요.",
    "관계운은 ‘{k}’에 달려 있습니다. 타이밍을 맞추면 일이 부드럽게 풀립니다.",
    "연애운은 ‘{k}’이 유리합니다. 말보다 ‘행동’이 신뢰를 만듭니다.",
    "관계는 ‘{k}’로 풀립니다. 기대치를 맞추면 오해가 크게 줄어듭니다.",
    "연애/관계는 ‘{k}’이 관건입니다. 감정이 올라올수록 한 박자 천천히 가세요.",
    "관계운은 ‘{k}’을 잘 쓰면 좋아집니다. ‘요청’과 ‘배려’를 분리해 말해보세요."
  ],
  health: [
    "건강운은 ‘{k}’이 중요합니다. 수면과 리듬을 먼저 잡으면 체력이 따라옵니다.",
    "건강은 ‘{k}’로 관리하세요. 무리한 몰아치기보다 꾸준함이 이깁니다.",
    "올해 몸은 ‘{k}’가 답입니다. 작은 신호는 초기에 케어하는 편이 좋습니다.",
    "건강운은 ‘{k}’에 달려 있습니다. 식사 시간만 일정해도 컨디션이 안정됩니다.",
    "건강은 ‘{k}’ 중심으로. 움직임과 휴식의 균형을 맞추는 게 핵심입니다.",
    "컨디션은 ‘{k}’로 바뀝니다. 일정을 줄이기보다 회복 시간을 먼저 확보해보세요."
  ]
};

// 월별 태그(뱃지) — 훨씬 크게
const MONTH_TAGS = [
  "준비","정리","가속","확장","정착","전환","재정비","상승","선택","수확","마무리","리셋",
  "협상","정비","발견","점검","실험","연결","정돈","정리","정착","확인","휴식","정렬",
  "돌파","정리","단단히","매듭","도약","정리","조정","스위치","정리"
];

// 월별 문장 유형별 풀 (서로 문장 결이 다름)
const MONTH_POOLS = {
  // "상황형" : 이달 분위기/흐름 서술
  situation: [
    "주변 상황이 먼저 움직이는 달입니다. 계획을 고집하기보다 흐름을 읽는 쪽이 유리합니다.",
    "작은 변수가 생기기 쉽습니다. ‘대응 가능한 일정’이 오히려 성과를 지켜줍니다.",
    "관심이 밖으로 향하는 달입니다. 새로운 정보가 들어오면 메모부터 해두세요.",
    "속도가 붙는 달입니다. 결정해야 할 일이 늘어도, 우선순위만 지키면 됩니다.",
    "판이 바뀌는 조짐이 보입니다. ‘지금 방식’이 영원하지 않다는 걸 받아들이면 편해집니다.",
    "이달은 정리보다 실행이 잘 맞습니다. 완벽함보다 ‘진행률’을 올려보세요.",
    "사람을 통해 힌트가 들어옵니다. 스쳐가는 말이 다음 달의 선택지가 됩니다.",
    "예상 밖의 기회가 눈에 띕니다. 큰 결정보다 ‘작게 테스트’가 안전합니다.",
    "마무리가 중요한 달입니다. 끝내는 감각이 다음 달의 여유를 만듭니다.",
    "되돌아보기가 필요한 달입니다. 지금의 속도가 적정한지 한 번 점검해보세요."
  ],

  // "행동형" : 오늘/이번주 해볼 행동 제안
  action: [
    "이번 달은 ‘하나만 끝내기’를 해보세요. 작아도 끝낸 경험이 리듬을 만듭니다.",
    "해야 할 일을 늘리기보다, 하지 않을 일을 3개만 정해보세요.",
    "작업을 ‘1회성’으로 하지 말고 템플릿으로 바꾸면 체감이 큽니다.",
    "메모/자료를 한 곳으로 모아보세요. 찾는 시간이 줄면 마음이 가벼워집니다.",
    "미뤄둔 연락 1건만 정리해도 흐름이 열립니다. 먼저 한 번만 움직여보세요.",
    "이번 달은 실험이 답입니다. 완성보다 ‘가설 → 확인’을 빠르게 돌려보세요.",
    "조용히 준비하고, 공개는 최소로 하세요. ‘완료 후 공유’가 가장 강합니다.",
    "딱 2시간만 ‘방해 금지’로 설정해보세요. 집중력이 결과를 끌어올립니다.",
    "당장 필요한 것만 구매/결정하세요. ‘나중에 쓸 것’은 보류가 유리합니다.",
    "이번 달은 ‘정리 데이’를 하루만 잡아보세요. 한 번의 정돈이 몇 주를 살립니다."
  ],

  // "주의형" : 조심할 포인트/리스크
  caution: [
    "속도를 올릴수록 실수가 나기 쉽습니다. 중요한 건 ‘두 번 확인’으로 막을 수 있습니다.",
    "감정이 앞설 수 있는 달입니다. 메시지는 바로 보내기보다 한 번만 읽고 보내세요.",
    "너무 많은 선택지를 한 번에 잡으면 지치기 쉽습니다. ‘하나씩’이 이깁니다.",
    "사람의 말에 흔들리기 쉽습니다. ‘내 기준’을 먼저 세우면 흔들림이 줄어듭니다.",
    "체력이 성과를 좌우합니다. 밤샘으로 해결하기보다 리듬을 지키는 편이 낫습니다.",
    "돈은 새는 구멍이 생기기 쉽습니다. 정기결제/구독만 확인해도 방어가 됩니다.",
    "관계에서 오해가 생길 수 있습니다. 확인 질문을 덧붙이면 대부분 예방됩니다.",
    "완벽주의가 발목을 잡을 수 있습니다. 70%에서 출발해도 충분히 보완됩니다.",
    "새 일을 무리하게 늘리기보다, 기존 것의 ‘마무리’부터 챙기세요.",
    "이번 달은 ‘과신’이 리스크입니다. 익숙한 일일수록 체크리스트가 필요합니다."
  ],

  // "관계형" : 사람/소통/협업 결
  social: [
    "이달은 협업에서 답이 나옵니다. 혼자 끌기보다 역할을 나누면 속도가 붙습니다.",
    "대화의 밀도가 높아지는 달입니다. ‘무엇을 원하는지’를 분명히 말하면 편해집니다.",
    "가까운 관계가 힘이 됩니다. 큰 조언보다 ‘작은 도움’을 받는 게 포인트입니다.",
    "누군가가 먼저 신호를 줍니다. 부담 없이 받아들이면 관계가 부드러워집니다.",
    "관계 정리가 자연스럽게 일어납니다. 억지로 유지하기보다 흐름을 따르세요.",
    "이달은 ‘요청’이 잘 통합니다. 부탁을 미루지 말고 한 번만 정확히 말해보세요.",
    "대화는 짧고 명확하게가 유리합니다. 장문의 설명보다 핵심 2줄이 더 강합니다.",
    "이달은 새로운 사람보다 기존 네트워크가 도움이 됩니다. 다시 연락해보세요.",
    "칭찬/감사가 관계의 문을 엽니다. 결과가 아니라 과정에 한 마디를 얹어보세요.",
    "협상은 ‘조건’보다 ‘기준’을 맞추는 데서 시작합니다. 기준을 먼저 공유해보세요."
  ],

  // "컨디션형" : 건강/리듬/회복 결
  rhythm: [
    "컨디션이 결과를 좌우합니다. 바쁠수록 수면 시간을 먼저 지키는 달입니다.",
    "무리의 여파가 쌓이기 쉽습니다. 회복 시간을 일정에 ‘예약’해두세요.",
    "이달은 몸이 신호를 줍니다. 작은 불편함을 초기에 정리하면 길게 편해집니다.",
    "리듬을 고치기 좋습니다. 아침/점심 중 하나만 일정하게 맞춰도 효과가 큽니다.",
    "기분이 흔들릴 수 있습니다. ‘운동 10분’ 같은 작은 루틴이 안정감을 줍니다.",
    "에너지가 회복되는 달입니다. 미뤄둔 일을 몰아치기보다 ‘꾸준히’가 유리합니다.",
    "과열되기 쉽습니다. 쉬는 날에 ‘아무것도 안 하는 시간’을 만들어보세요.",
    "이달은 정리보다 회복이 먼저입니다. 덜 해도 괜찮다는 허용이 필요합니다.",
    "식사/수분 같은 기본이 체감 차이를 만듭니다. 작은 기본부터 챙겨보세요.",
    "몸이 가벼워지는 흐름입니다. 움직임을 늘리되, 무리한 목표는 피하세요."
  ],

  // "미션형" : 한 줄 미션(게임처럼)
  mission: [
    "미션: ‘안 쓰는 것 10개’ 정리하기. 공간이 비면 생각도 정리됩니다.",
    "미션: ‘미뤄둔 일 1건’ 끝내기. 끝낸 감각이 다음 일을 끌어옵니다.",
    "미션: ‘연락 1명’ 먼저 하기. 작은 대화가 큰 흐름을 만듭니다.",
    "미션: ‘체크리스트’ 만들기. 실수 한 번을 막으면 한 달이 편해집니다.",
    "미션: ‘30분 집중’ 3회 만들기. 짧은 집중이 성과를 만듭니다.",
    "미션: ‘정기결제’ 점검하기. 불필요한 지출이 생각보다 많습니다.",
    "미션: ‘버리고/미루고/위임’ 중 하나 선택하기. 할 일이 줄어듭니다.",
    "미션: ‘일정 비우기’ 하루 만들기. 여백이 문제 해결을 합니다.",
    "미션: ‘기록’ 시작하기. 한 줄이라도 남기면 방향이 보입니다.",
    "미션: ‘칭찬 한 마디’ 하기. 관계가 부드러워지면 일이 빨라집니다."
  ]
};

// 월별 유형(어떤 달은 상황형, 어떤 달은 미션형…) — 12개월에 골고루 배치
// 이 배열 자체도 시드로 셔플해서 사람마다 배치가 달라짐
const MONTH_TYPES_BASE = [
  "situation","action","social","caution","rhythm","mission",
  "situation","action","social","caution","rhythm","mission"
];

// 월별 문장에 넣을 "키워드/초점" (문장 다양화용)
const FOCUSES = [
  "정리","속도","방향","우선순위","집중","협업","대화","회복","체력","돈관리","선택","마무리",
  "기록","템플릿","확인","테스트","조정","기준","경계","요청","정돈","리듬","정리 데이","루틴"
];

// 월별 문장에 약간의 변주를 주는 "후속 한 줄" 풀
const AFTER_LINES = [
  "작게 시작하면 부담이 줄어듭니다.",
  "딱 하나만 정해도 충분합니다.",
  "완벽보다 진행이 이깁니다.",
  "기준이 생기면 마음이 편해집니다.",
  "한 번 더 확인하면 대부분 해결됩니다.",
  "지금 페이스를 유지하는 게 좋습니다.",
  "오늘 할 수 있는 것부터 가볍게.",
  "욕심을 줄이면 결과가 더 좋아집니다.",
  "대화는 짧고 명확하게가 유리합니다.",
  "정리와 실행의 균형을 맞춰보세요."
];

// “큰 흐름” 문장 변주(사람마다 톤 차이)
const FLOW_TAILS = [
  "올해는 ‘{k}’이 전체 키워드입니다.",
  "핵심은 ‘{k}’입니다. 이 기준만 지키면 흔들림이 줄어듭니다.",
  "올해는 ‘{k}’을 잘 쓰면 기회가 자주 보입니다.",
  "올해는 ‘{k}’이 성과를 좌우합니다. 작게라도 계속 이어가 보세요.",
  "올해는 ‘{k}’이 반복해서 등장합니다. 같은 선택을 줄이는 게 포인트입니다."
];

/* ===================== 월별 생성: 최대한 안 겹치게 =====================
   목표:
   - 12개월 문장 자체가 서로 겹치지 않게 (중복 선택 방지)
   - 태그/유형도 사람마다 다르게 배치
   - 문장 구조가 매달 달라 보이게 (유형 혼합 + 후속 한 줄 변주)
*/
function buildMonthly(seed){
  // 사람마다 월별 유형 배치가 다르게
  const types = shuffleWithSeed(MONTH_TYPES_BASE, xorshift32(seed ^ 0xA1B2C3D4));

  // 태그/포커스/후속 문장을 중복 없이 최대한 뽑기
  const tags = sampleUnique(MONTH_TAGS, 12, seed, 0x11);
  const focuses = sampleUnique(FOCUSES, 12, seed, 0x22);
  const afters = sampleUnique(AFTER_LINES, 12, seed, 0x33);

  // 각 유형별 풀은 "중복 없이" 쓰기 위해 셔플한 뒤 차례대로 소비
  const poolsShuffled = {};
  for(const t of Object.keys(MONTH_POOLS)){
    poolsShuffled[t] = shuffleWithSeed(MONTH_POOLS[t], xorshift32(seed ^ (t.length * 0x9e3779b9)));
  }
  const poolCursor = Object.fromEntries(Object.keys(MONTH_POOLS).map(t=>[t,0]));

  function nextFromPool(type){
    const arr = poolsShuffled[type];
    let idx = poolCursor[type] || 0;
    if(idx >= arr.length){
      // 다 쓰면 다시 셔플 (현실적으로 12개월이면 거의 안 닿음)
      poolsShuffled[type] = shuffleWithSeed(arr, xorshift32(seed ^ (idx + 777)));
      idx = 0;
    }
    poolCursor[type] = idx + 1;
    return poolsShuffled[type][idx];
  }

  // 12개월 생성
  const months = [];
  for(let i=1; i<=12; i++){
    const type = types[i-1];
    const base = nextFromPool(type);

    // 문장에 "포커스"를 살짝 끼워 넣어 변주(유형별로 자연스럽게)
    // 너무 인위적이지 않게 50% 확률로만 추가
    const r = xorshift32(seed ^ (0x5000 + i));
    const addFocus = (r % 2 === 0);

    let text = base;
    if(addFocus){
      const f = focuses[i-1];
      // 유형별로 들어가는 방식 변주
      if(type === "action" || type === "mission"){
        text = text.replace("미션:", "미션:").replace(".", ""); // 미션은 깔끔하게
        text = `${text} (초점: ${f})`;
      } else if(type === "caution"){
        text = `${text} (초점: ${f})`;
      } else if(type === "social"){
        text = `${text} (초점: ${f})`;
      } else if(type === "rhythm"){
        text = `${text} (초점: ${f})`;
      } else {
        text = `${text} (초점: ${f})`;
      }
    }

    // 후속 한 줄(매달 톤 다르게)
    const tail = afters[i-1];
    // 미션형은 후속문장을 빼면 더 게임처럼 깔끔해서 50%만 붙임
    const attachTail = (type !== "mission") ? true : ((xorshift32(seed ^ (0x9000 + i)) % 2) === 0);
    if(attachTail){
      text = `${text} ${tail}`;
    }

    months.push({
      month: i,
      tag: tags[i-1],
      type,
      text
    });
  }

  // 같은 사람이 12개월 안에서 문장이 너무 비슷하게 느껴질 때를 대비해,
  // "완전 동일한 텍스트"가 있으면(거의 없지만) 마지막 안전장치로 한 번 더 섞기
  const seen = new Set();
  for(const m of months){
    if(seen.has(m.text)){
      // 중복이면 다른 유형 풀에서 한 번 더 가져오기
      const altType = pickOne(Object.keys(MONTH_POOLS), seed, 0xDEAD0000 + m.month);
      m.type = altType;
      m.text = nextFromPool(altType) + " " + pickOne(AFTER_LINES, seed, 0xBEEF0000 + m.month);
    }
    seen.add(m.text);
  }

  return months;
}

/* ===================== 연간/분야별 운세 생성 ===================== */
function buildFortune(y,m,d){
  const seed = makeSeed(y,m,d);

  const animal = chineseZodiac(y);
  const sign = westernSign(m,d);

  const theme = pickOne(YEAR_THEMES, seed, 0x4000);
  const yearKeyword = pickOne(KEYWORDS, seed, 0x5000);
  const flowTail = fill(pickOne(FLOW_TAILS, seed, 0x6000), {k: yearKeyword});
  const bigFlow = `${theme.flow} ${flowTail}`;

  const workK   = pickOne(KEYWORDS, seed, 0x7001);
  const moneyK  = pickOne(KEYWORDS, seed, 0x7002);
  const loveK   = pickOne(KEYWORDS, seed, 0x7003);
  const healthK = pickOne(KEYWORDS, seed, 0x7004);

  const work   = fill(pickOne(FIELD_TEMPLATES.work, seed, 0x8001),   {k: workK});
  const money  = fill(pickOne(FIELD_TEMPLATES.money, seed, 0x8002),  {k: moneyK});
  const love   = fill(pickOne(FIELD_TEMPLATES.love, seed, 0x8003),   {k: loveK});
  const health = fill(pickOne(FIELD_TEMPLATES.health, seed, 0x8004), {k: healthK});

  const months = buildMonthly(seed);

  return { animal, sign, themeTitle: theme.title, bigFlow, work, money, love, health, months };
}

/* ===================== 렌더 ===================== */
function render(data){
  const monthsHtml = data.months.map(m => `
    <div class="month">
      <div class="m-title">
        <span>${m.month}월</span>
        <span class="pill">${escapeHtml(m.tag)}</span>
      </div>
      <p>${escapeHtml(m.text)}</p>
    </div>
  `).join("");

  elOut.innerHTML = `
    <div class="badge">${escapeHtml(data.animal)}띠 · ${escapeHtml(data.sign)}</div>

    <div class="grid grid-2">
      <div class="card">
        <h2>2026 큰 흐름</h2>
        <div class="kvs">
          <div class="kv"><b>테마</b> ${escapeHtml(data.themeTitle)}</div>
        </div>
        <p class="lead">${escapeHtml(data.bigFlow)}</p>
      </div>

      <div class="card">
        <h2>분야별 운세</h2>
        <h3>일</h3><p class="lead">${escapeHtml(data.work)}</p>
        <h3>돈</h3><p class="lead">${escapeHtml(data.money)}</p>
        <h3>연애/관계</h3><p class="lead">${escapeHtml(data.love)}</p>
        <h3>건강</h3><p class="lead">${escapeHtml(data.health)}</p>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>월별 포인트</h2>
      <div class="months">${monthsHtml}</div>
    </div>
  `;
}

/* ===================== 유효성 검사 + 실행 ===================== */
function parseInputs(){
  const yRaw = onlyDigits(elY.value).slice(0,4);
  const mRaw = onlyDigits(elM.value).slice(0,2);
  const dRaw = onlyDigits(elD.value).slice(0,2);

  if(yRaw.length !== 4) return { ok:false, msg:"연도(YYYY) 4자리를 입력해 주세요." };
  if(mRaw.length !== 2) return { ok:false, msg:"월(MM) 2자리를 입력해 주세요. (예: 04)" };
  if(dRaw.length !== 2) return { ok:false, msg:"일(DD) 2자리를 입력해 주세요. (예: 17)" };

  const y = parseInt(yRaw, 10);
  const m = parseInt(mRaw, 10);
  if(!(y >= 1900 && y <= 2026)) return { ok:false, msg:"연도는 1900~2026 범위로 입력해 주세요." };
  if(!(m >= 1 && m <= 12)) return { ok:false, msg:"월은 01~12 범위로 입력해 주세요." };

  const dim = daysInMonth(y, m);
  const d = parseInt(dRaw, 10);
  if(!(d >= 1 && d <= dim)) return { ok:false, msg:`일은 해당 월의 01~${String(dim).padStart(2,"0")} 범위로 입력해 주세요.` };

  // 보기 좋게 패딩 반영
  elY.value = String(y);
  elM.value = String(m).padStart(2,"0");
  elD.value = String(d).padStart(2,"0");

  return { ok:true, y, m, d };
}

function showFortune(){
  setError("");
  const p = parseInputs();
  if(!p.ok){
    setError(p.msg);
    elOut.style.display = "none";
    return;
  }
  const data = buildFortune(p.y, p.m, p.d);
  elOut.style.display = "block";
  render(data);
}
</script>
</body>
</html>
