<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI 2026 신년운세</title>
  <style>
    :root{
      --bg:#f9fafb; --card:#ffffff; --line:#e5e7eb; --muted:#6b7280;
      --accent:#ff7a00; --accentBg:#fff3e8; --text:#111827;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans KR",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      margin:0; padding:24px;
      color:var(--text);
    }
    .wrap{
      max-width: 960px;
      margin: 0 auto;
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 25px rgba(0,0,0,.06);
    }
    h1{ margin:0 0 6px; font-size:22px; }
    .sub{ margin:0 0 14px; color:var(--muted); font-size:13px; line-height:1.45; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .datepack{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .sep{ color:var(--muted); user-select:none; }

    input[type="text"]{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      font-size: 14px;
      background: #fff;
      outline: none;
    }
    input[type="text"]:focus{
      border-color: rgba(255,122,0,.55);
      box-shadow: 0 0 0 3px rgba(255,122,0,.12);
    }
    .y{ width: 120px; }
    .m,.d{ width: 84px; }

    button{
      padding: 10px 16px;
      border-radius: 10px;
      border: none;
      background: var(--accent);
      color: white;
      font-weight: 900;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active{ transform: translateY(1px); }

    .hint{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    .err{
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #fecaca;
      background: #fff1f2;
      color: #991b1b;
      border-radius: 12px;
      display:none;
      font-size: 13px;
      line-height: 1.45;
    }

    .result{
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px solid var(--line);
      display:none;
    }
    .badge{
      display:inline-block;
      padding: 5px 10px;
      border-radius: 999px;
      background: var(--accentBg);
      color: var(--accent);
      font-size: 12px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 860px){
      .grid-2{ grid-template-columns: 1fr 1fr; }
    }
    .card{
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 14px 12px;
      background: #fff;
    }
    .card h2{ margin: 0 0 8px; font-size: 16px; }
    .card h3{ margin: 10px 0 6px; font-size: 14px; }
    .lead{ font-size: 14px; line-height: 1.55; margin: 6px 0 0; }
    .kvs{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom: 8px; }
    .kv{
      padding: 6px 10px;
      border-radius: 12px;
      background: #f3f4f6;
      font-size: 12px;
    }
    .kv b{ font-weight: 900; }

    .months{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    @media (min-width: 860px){
      .months{ grid-template-columns: 1fr 1fr; }
    }
    .month{
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fff;
    }
    .month .m-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      font-size: 13px;
      margin-bottom: 6px;
    }
    .pill{
      font-size: 11px;
      font-weight: 900;
      background: var(--accentBg);
      color: var(--accent);
      padding: 3px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }
    .month p{ margin:0; font-size: 13px; line-height: 1.45; }

    .foot{
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AI로 보는 2026년 운세</h1>
    <p class="sub">생년월일을 입력하면 2026년 전체 운세(큰 흐름 + 분야별 + 월별 포인트)가 표시됩니다.</p>

    <div class="row">
      <div class="datepack" aria-label="생년월일 입력">
        <input id="year" class="y" type="text" inputmode="numeric" autocomplete="bday-year"
               placeholder="YYYY" maxlength="4" aria-label="출생 연도(4자리)" />
        <span class="sep">-</span>
        <input id="month" class="m" type="text" inputmode="numeric" autocomplete="bday-month"
               placeholder="MM" maxlength="2" aria-label="출생 월(2자리)" />
        <span class="sep">-</span>
        <input id="day" class="d" type="text" inputmode="numeric" autocomplete="bday-day"
               placeholder="DD" maxlength="2" aria-label="출생 일(2자리)" />
      </div>

      <button id="go" type="button">운세 보기</button>
    </div>

    <div class="hint">
      연도 4자리 입력하면 월로 이동, 월 2자리 입력하면 일로 이동합니다. 일 2자리까지 입력하면 자동으로 결과가 표시됩니다.
      <br/>결과는 같은 생년월일이면 항상 동일하게 나옵니다.
    </div>

    <div id="err" class="err"></div>
    <div id="out" class="result"></div>

    <div class="foot">
      ※ 재미로 가볍게 보는 콘텐츠입니다. 개인의 선택과 노력에 따라 결과는 달라질 수 있습니다.
    </div>
  </div>

<script>
/* ===================== 입력 UX: 숫자만 + 자동 이동 + 0 패딩 ===================== */
const elY = document.getElementById("year");
const elM = document.getElementById("month");
const elD = document.getElementById("day");
const elGo = document.getElementById("go");
const elErr = document.getElementById("err");
const elOut = document.getElementById("out");

function onlyDigits(s){ return (s || "").replace(/\D/g, ""); }

function setError(msg){
  if(!msg){
    elErr.style.display = "none";
    elErr.textContent = "";
    return;
  }
  elErr.style.display = "block";
  elErr.textContent = msg;
}

function clampInt(v, min, max){
  const n = parseInt(v, 10);
  if(Number.isNaN(n)) return null;
  if(n < min) return min;
  if(n > max) return max;
  return n;
}

function daysInMonth(year, month){
  return new Date(year, month, 0).getDate();
}

function normalizeYear(){
  let y = onlyDigits(elY.value).slice(0,4);
  elY.value = y;
}
function normalizeMonth(){
  let m = onlyDigits(elM.value).slice(0,2);
  if(m.length === 0){ elM.value = ""; return; }
  if(m.length === 1){ elM.value = m; return; }
  const mi = clampInt(m, 1, 12);
  elM.value = String(mi).padStart(2, "0");
}
function normalizeDayFor(year, month){
  let d = onlyDigits(elD.value).slice(0,2);
  if(d.length === 0){ elD.value = ""; return; }
  if(d.length === 1){ elD.value = d; return; }
  const dim = daysInMonth(year, month);
  const di = clampInt(d, 1, dim);
  elD.value = String(di).padStart(2, "0");
}

function autoAdvance(fromEl, maxLen, toEl){
  const v = onlyDigits(fromEl.value);
  if(v.length >= maxLen){
    fromEl.value = v.slice(0, maxLen);
    if(toEl){
      toEl.focus();
      toEl.select?.();
    }
  }
}

elY.addEventListener("input", () => { normalizeYear(); autoAdvance(elY, 4, elM); });
elM.addEventListener("input", () => { elM.value = onlyDigits(elM.value).slice(0,2); autoAdvance(elM, 2, elD); });
elD.addEventListener("input", () => {
  elD.value = onlyDigits(elD.value).slice(0,2);
  if(onlyDigits(elD.value).length === 2){
    showFortune();
  }
});

elM.addEventListener("blur", () => normalizeMonth());
elD.addEventListener("blur", () => {
  const y = parseInt(elY.value, 10);
  const m = parseInt(elM.value, 10);
  if(!Number.isNaN(y) && !Number.isNaN(m)){
    normalizeMonth();
    normalizeDayFor(y, m);
  } else {
    elD.value = onlyDigits(elD.value).slice(0,2);
    if(elD.value.length === 1) elD.value = "0" + elD.value;
  }
});

function onEnterMove(e, next){
  if(e.key === "Enter"){
    e.preventDefault();
    if(next){ next.focus(); next.select?.(); }
    else { showFortune(); }
  }
}
elY.addEventListener("keydown", (e)=>onEnterMove(e, elM));
elM.addEventListener("keydown", (e)=>onEnterMove(e, elD));
elD.addEventListener("keydown", (e)=>onEnterMove(e, null));

elGo.addEventListener("click", showFortune);
window.addEventListener("load", () => elY.focus());

/* ===================== 띠/별자리 ===================== */
const ZODIAC = ["쥐","소","호랑이","토끼","용","뱀","말","양","원숭이","닭","개","돼지"];
function chineseZodiac(year){
  const idx = (year - 1900) % 12;
  return ZODIAC[(idx + 12) % 12];
}
function westernSign(month, day){
  if ((month===3 && day>=21) || (month===4 && day<=19)) return "양자리";
  if ((month===4 && day>=20) || (month===5 && day<=20)) return "황소자리";
  if ((month===5 && day>=21) || (month===6 && day<=20)) return "쌍둥이자리";
  if ((month===6 && day>=21) || (month===7 && day<=22)) return "게자리";
  if ((month===7 && day>=23) || (month===8 && day<=22)) return "사자자리";
  if ((month===8 && day>=23) || (month===9 && day<=22)) return "처녀자리";
  if ((month===9 && day>=23) || (month===10 && day<=22)) return "천칭자리";
  if ((month===10 && day>=23) || (month===11 && day<=21)) return "전갈자리";
  if ((month===11 && day>=22) || (month===12 && day<=21)) return "사수자리";
  if ((month===12 && day>=22) || (month===1 && day<=19)) return "염소자리";
  if ((month===1 && day>=20) || (month===2 && day<=18)) return "물병자리";
  return "물고기자리";
}

/* ===================== 결정적 시드/셔플 ===================== */
function xorshift32(x){
  x >>>= 0;
  x ^= (x << 13) >>> 0;
  x ^= (x >>> 17) >>> 0;
  x ^= (x << 5) >>> 0;
  return x >>> 0;
}
function makeSeed(y,m,d){
  let s = ((y & 0xffff) << 16) ^ ((m & 0xff) << 8) ^ (d & 0xff);
  s ^= 0x9e3779b9;
  s = xorshift32(s);
  s = xorshift32(s ^ (y * 2654435761 >>> 0));
  s = xorshift32(s ^ (m * 1597334677 >>> 0));
  s = xorshift32(s ^ (d * 3812015801 >>> 0));
  return s >>> 0;
}
function rnd01(seedObj){
  seedObj.v = xorshift32(seedObj.v);
  return seedObj.v / 0x100000000;
}
function shuffleWithSeed(arr, seed){
  const a = arr.slice();
  const s = {v: seed >>> 0};
  for(let i=a.length-1; i>0; i--){
    const j = Math.floor(rnd01(s) * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function pickOne(arr, seed, salt){
  const s = xorshift32((seed ^ salt) >>> 0);
  return arr[s % arr.length];
}
function sampleUnique(arr, n, seed, salt){
  const order = shuffleWithSeed(arr, xorshift32((seed ^ salt) >>> 0));
  return order.slice(0, Math.min(n, order.length));
}
function fill(t, vars){
  return t.replace(/\{(\w+)\}/g, (_,k)=> String(vars[k] ?? ""));
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* ===================== 콘텐츠 ===================== */
const YEAR_THEMES = [
  { title: "정리 후 가속", flow: "상반기는 정리와 재배치, 하반기는 속도와 확장이 함께 옵니다." },
  { title: "선택과 집중", flow: "할 일을 줄일수록 결과가 커집니다. 방향을 잡으면 실행이 빨라집니다." },
  { title: "연결의 해", flow: "사람·정보·기회가 ‘연결’로 들어옵니다. 혼자보다 함께가 유리합니다." },
  { title: "기본기 강화", flow: "한 번의 큰 성과보다, 작은 습관이 누적되며 판이 바뀝니다." },
  { title: "전환점", flow: "작은 결단이 큰 전환을 만듭니다. 속도보다 방향이 중요합니다." },
  { title: "회복과 리셋", flow: "무리했던 루틴을 정리하고 회복하는 흐름입니다. 템포를 맞추면 안정됩니다." },
  { title: "확장과 브랜딩", flow: "성과를 밖으로 보여주는 해입니다. 포지션을 정하면 기회가 따라옵니다." },
  { title: "안정적 상승", flow: "큰 변동보다 안정적인 상승입니다. 꾸준함이 가장 강한 전략입니다." }
];

const KEYWORDS = [
  "정리","도약","균형","집중","확장","안정","관계","루틴","결단","유연함","성장","회복",
  "정착","전환","수확","협상","속도","완성","정비","발견","선별","설득","실행","휴식"
];

const FLOW_TAILS = [
  "올해는 ‘{k}’이 전체 키워드입니다.",
  "핵심은 ‘{k}’입니다. 이 기준만 지키면 흔들림이 줄어듭니다.",
  "올해는 ‘{k}’을 잘 쓰면 기회가 자주 보입니다.",
  "올해는 ‘{k}’이 성과를 좌우합니다. 작게라도 계속 이어가 보세요.",
  "올해는 ‘{k}’이 반복해서 등장합니다. 같은 선택을 줄이는 게 포인트입니다."
];

const FIELD_TEMPLATES = {
  work: [
    "업무는 ‘{k}’이 관건입니다. 먼저 기준을 세우면 속도가 따라옵니다.",
    "일에서는 ‘{k}’이 성과로 이어집니다. 시작은 빠르게, 마무리는 단단하게 잡아보세요.",
    "업무운은 ‘{k}’ 쪽이 유리합니다. 협업은 역할을 명확히 하면 마찰이 줄어듭니다.",
    "올해 일은 ‘{k}’에 달려 있습니다. 한 번에 크게보다, 단계적으로 쌓는 편이 좋습니다.",
    "일에서 ‘{k}’을 선택하면 실수가 줄고, 신뢰가 늘어납니다.",
    "업무는 ‘{k}’을 기준으로 정리하면 편해집니다. 반복 작업을 템플릿화해 보세요.",
    "일은 ‘{k}’로 풀립니다. 중요한 건 더 하기보다 덜어내기입니다."
  ],
  money: [
    "돈은 ‘{k}’ 방식이 안전합니다. 큰 결정보다 관리와 분산이 유리합니다.",
    "금전운은 ‘{k}’이 핵심입니다. 고정비를 점검해보면 체감이 큽니다.",
    "재정은 ‘{k}’로 가면 편합니다. 수입보다 새는 돈부터 잡아보세요.",
    "돈에서는 ‘{k}’이 답입니다. 계획한 소비는 괜찮고, 즉흥은 줄일수록 좋아요.",
    "금전은 ‘{k}’이 잘 맞습니다. 지킬 때 지키는 게 중요합니다.",
    "돈은 ‘{k}’로 안정됩니다. 예산을 작게 나누면 덜 흔들립니다."
  ],
  love: [
    "연애/관계는 ‘{k}’이 포인트입니다. 표현은 짧게, 확인은 한 번 더 해보세요.",
    "관계운은 ‘{k}’에 달려 있습니다. 타이밍을 맞추면 일이 부드럽게 풀립니다.",
    "연애운은 ‘{k}’이 유리합니다. 말보다 행동이 신뢰를 만듭니다.",
    "관계는 ‘{k}’로 풀립니다. 기대치를 맞추면 오해가 크게 줄어듭니다.",
    "연애/관계는 ‘{k}’이 관건입니다. 감정이 올라올수록 한 박자 천천히 가세요.",
    "관계운은 ‘{k}’을 잘 쓰면 좋아집니다. 요청과 배려를 분리해 말해보세요."
  ],
  health: [
    "건강운은 ‘{k}’이 중요합니다. 수면과 리듬을 먼저 잡으면 체력이 따라옵니다.",
    "건강은 ‘{k}’로 관리하세요. 무리한 몰아치기보다 꾸준함이 이깁니다.",
    "올해 몸은 ‘{k}’가 답입니다. 작은 신호는 초기에 케어하는 편이 좋습니다.",
    "건강운은 ‘{k}’에 달려 있습니다. 식사 시간만 일정해도 컨디션이 안정됩니다.",
    "건강은 ‘{k}’ 중심으로. 움직임과 휴식의 균형이 핵심입니다.",
    "컨디션은 ‘{k}’로 바뀝니다. 회복 시간을 먼저 확보해보세요."
  ]
};

const MONTH_TAGS = [
  "준비","정리","가속","확장","정착","전환","재정비","상승","선택","수확","마무리","리셋",
  "협상","정비","발견","점검","실험","연결","정돈","확인","휴식","조정","돌파","매듭",
  "스위치","정렬","정착","전개","정리","완성","보완","재배치"
];

const MONTH_POOLS = {
  situation: [
    "주변 상황이 먼저 움직이는 달입니다. 계획을 고집하기보다 흐름을 읽는 쪽이 유리합니다.",
    "작은 변수가 생기기 쉽습니다. 대응 가능한 일정을 잡는 것이 도움이 됩니다.",
    "관심이 밖으로 향하는 달입니다. 새로 들어오는 정보는 기록부터 해두세요.",
    "속도가 붙는 달입니다. 우선순위만 지키면 성과가 따라옵니다.",
    "판이 바뀌는 조짐이 보입니다. 지금 방식을 고집하기보다 조정을 고려해보세요.",
    "마무리가 중요한 달입니다. 끝내는 감각이 다음 달의 여유를 만듭니다.",
    "사람을 통해 힌트가 들어옵니다. 스쳐가는 말이 선택지가 될 수 있습니다.",
    "예상 밖의 기회가 보입니다. 큰 결정보다 작게 테스트가 유리합니다.",
    "되돌아보기가 필요한 달입니다. 현재 속도가 적정한지 점검해보세요."
  ],
  action: [
    "이번 달은 하나만 끝내기를 해보세요. 작아도 끝낸 경험이 리듬을 만듭니다.",
    "해야 할 일을 늘리기보다 하지 않을 일을 3개만 정해보세요.",
    "작업을 1회성으로 하지 말고 템플릿으로 바꿔보세요.",
    "자료를 한 곳으로 모아보세요. 찾는 시간이 줄면 마음도 가벼워집니다.",
    "미뤄둔 연락 1건만 정리해도 흐름이 열립니다. 먼저 한 번만 움직여보세요.",
    "완성보다 가설과 확인을 빠르게 돌려보세요.",
    "딱 2시간만 방해 금지로 설정해보세요. 집중이 결과를 끌어올립니다.",
    "정리 데이를 하루만 잡아보세요. 한 번의 정돈이 몇 주를 살립니다."
  ],
  caution: [
    "속도를 올릴수록 실수가 나기 쉽습니다. 중요한 건 두 번 확인으로 막을 수 있습니다.",
    "감정이 앞설 수 있습니다. 메시지는 한 번만 읽고 보내면 오해가 줄어듭니다.",
    "선택지를 한 번에 많이 잡으면 지치기 쉽습니다. 하나씩 처리하는 편이 좋습니다.",
    "사람의 말에 흔들리기 쉽습니다. 기준을 먼저 세우면 흔들림이 줄어듭니다.",
    "체력이 성과를 좌우합니다. 몰아치기보다 리듬을 지키는 편이 낫습니다.",
    "완벽주의가 발목을 잡을 수 있습니다. 70%에서 시작해도 충분히 보완됩니다."
  ],
  social: [
    "협업에서 답이 나옵니다. 역할을 나누면 속도가 붙습니다.",
    "대화의 밀도가 높아집니다. 원하는 바를 분명히 말하면 편해집니다.",
    "기존 네트워크가 도움이 됩니다. 다시 연락해보세요.",
    "요청이 잘 통하는 달입니다. 부탁을 미루지 말고 정확히 말해보세요.",
    "칭찬과 감사가 관계의 문을 엽니다. 과정에 한 마디를 얹어보세요."
  ],
  rhythm: [
    "컨디션이 결과를 좌우합니다. 바쁠수록 수면 시간을 먼저 지키는 달입니다.",
    "회복 시간을 일정에 예약해두면 체감이 좋아집니다.",
    "몸이 신호를 줍니다. 작은 불편함을 초기에 정리하면 길게 편합니다.",
    "리듬을 고치기 좋습니다. 하루 중 한 끼만 일정하게 맞춰도 효과가 큽니다.",
    "기분이 흔들릴 수 있습니다. 짧은 산책 같은 작은 루틴이 안정감을 줍니다."
  ],
  mission: [
    "미션: 안 쓰는 것 10개 정리하기. 공간이 비면 생각도 정리됩니다.",
    "미션: 미뤄둔 일 1건 끝내기. 끝낸 감각이 다음 일을 끌어옵니다.",
    "미션: 연락 1명 먼저 하기. 작은 대화가 큰 흐름을 만듭니다.",
    "미션: 체크리스트 만들기. 실수 한 번을 막으면 한 달이 편해집니다.",
    "미션: 정기결제 점검하기. 불필요한 지출을 줄이는 데 도움이 됩니다."
  ]
};

const MONTH_TYPES_BASE = [
  "situation","action","social","caution","rhythm","mission",
  "situation","action","social","caution","rhythm","mission"
];

const FOCUSES = [
  "정리","속도","방향","우선순위","집중","협업","대화","회복","체력","돈관리","선택","마무리",
  "기록","템플릿","확인","테스트","조정","기준","요청","정돈","리듬","루틴","정리 데이","매듭"
];

const AFTER_LINES = [
  "작게 시작해도 충분합니다.",
  "완벽보다 진행이 중요합니다.",
  "한 번 더 확인하면 편해집니다.",
  "욕심을 줄이면 결과가 좋아집니다.",
  "지금 페이스를 유지하는 게 좋습니다.",
  "오늘 할 수 있는 것부터 가볍게 해보세요.",
  "기준을 세우면 마음이 편해집니다.",
  "짧게라도 꾸준히가 유리합니다."
];

/* ===================== 월별 생성: 다양화 + 중복 최소화 ===================== */
function buildMonthly(seed){
  const types = shuffleWithSeed(MONTH_TYPES_BASE, xorshift32(seed ^ 0xA1B2C3D4));
  const tags = sampleUnique(MONTH_TAGS, 12, seed, 0x11);
  const focuses = sampleUnique(FOCUSES, 12, seed, 0x22);
  const afters = sampleUnique(AFTER_LINES, 12, seed, 0x33);

  const poolsShuffled = {};
  for(const t of Object.keys(MONTH_POOLS)){
    poolsShuffled[t] = shuffleWithSeed(MONTH_POOLS[t], xorshift32(seed ^ (t.length * 0x9e3779b9)));
  }
  const poolCursor = Object.fromEntries(Object.keys(MONTH_POOLS).map(t=>[t,0]));

  function nextFromPool(type){
    const arr = poolsShuffled[type];
    let idx = poolCursor[type] || 0;
    if(idx >= arr.length){
      poolsShuffled[type] = shuffleWithSeed(arr, xorshift32(seed ^ (idx + 777)));
      idx = 0;
    }
    poolCursor[type] = idx + 1;
    return poolsShuffled[type][idx];
  }

  const months = [];
  for(let i=1; i<=12; i++){
    const type = types[i-1];
    let text = nextFromPool(type);

    const r = xorshift32(seed ^ (0x5000 + i));
    const addFocus = (r % 2 === 0);
    if(addFocus){
      const f = focuses[i-1];
      if(type === "mission"){
        text = `${text} (초점: ${f})`;
      } else {
        text = `${text} (초점: ${f})`;
      }
    }

    const tail = afters[i-1];
    const attachTail = (type !== "mission") ? true : ((xorshift32(seed ^ (0x9000 + i)) % 2) === 0);

    /* 핵심 수정: undefined 방지 + 문장 끝 공백 정리 */
    if(attachTail && tail){
      text = `${text} ${tail}`.trim();
    }

    months.push({ month: i, tag: tags[i-1], type, text });
  }

  const seen = new Set();
  for(const m of months){
    if(seen.has(m.text)){
      const altType = pickOne(Object.keys(MONTH_POOLS), seed, 0xDEAD0000 + m.month);
      m.type = altType;
      const altTail = pickOne(AFTER_LINES, seed, 0xBEEF0000 + m.month);
      m.text = `${nextFromPool(altType)} ${altTail}`.trim();
    }
    seen.add(m.text);
  }
  return months;
}

/* ===================== 연간/분야별 운세 ===================== */
function buildFortune(y,m,d){
  const seed = makeSeed(y,m,d);

  const animal = chineseZodiac(y);
  const sign = westernSign(m,d);

  const theme = pickOne(YEAR_THEMES, seed, 0x4000);
  const yearKeyword = pickOne(KEYWORDS, seed, 0x5000);
  const flowTail = fill(pickOne(FLOW_TAILS, seed, 0x6000), {k: yearKeyword});
  const bigFlow = `${theme.flow} ${flowTail}`;

  const workK   = pickOne(KEYWORDS, seed, 0x7001);
  const moneyK  = pickOne(KEYWORDS, seed, 0x7002);
  const loveK   = pickOne(KEYWORDS, seed, 0x7003);
  const healthK = pickOne(KEYWORDS, seed, 0x7004);

  const work   = fill(pickOne(FIELD_TEMPLATES.work, seed, 0x8001),   {k: workK});
  const money  = fill(pickOne(FIELD_TEMPLATES.money, seed, 0x8002),  {k: moneyK});
  const love   = fill(pickOne(FIELD_TEMPLATES.love, seed, 0x8003),   {k: loveK});
  const health = fill(pickOne(FIELD_TEMPLATES.health, seed, 0x8004), {k: healthK});

  const months = buildMonthly(seed);
  return { animal, sign, themeTitle: theme.title, bigFlow, work, money, love, health, months };
}

/* ===================== 렌더 ===================== */
function render(data){
  const monthsHtml = data.months.map(m => `
    <div class="month">
      <div class="m-title">
        <span>${m.month}월</span>
        <span class="pill">${escapeHtml(m.tag)}</span>
      </div>
      <p>${escapeHtml(m.text)}</p>
    </div>
  `).join("");

  elOut.innerHTML = `
    <div class="badge">${escapeHtml(data.animal)}띠 · ${escapeHtml(data.sign)}</div>

    <div class="grid grid-2">
      <div class="card">
        <h2>2026 큰 흐름</h2>
        <div class="kvs">
          <div class="kv"><b>테마</b> ${escapeHtml(data.themeTitle)}</div>
        </div>
        <p class="lead">${escapeHtml(data.bigFlow)}</p>
      </div>

      <div class="card">
        <h2>분야별 운세</h2>
        <h3>일</h3><p class="lead">${escapeHtml(data.work)}</p>
        <h3>돈</h3><p class="lead">${escapeHtml(data.money)}</p>
        <h3>연애/관계</h3><p class="lead">${escapeHtml(data.love)}</p>
        <h3>건강</h3><p class="lead">${escapeHtml(data.health)}</p>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>월별 포인트</h2>
      <div class="months">${monthsHtml}</div>
    </div>
  `;
}

/* ===================== 유효성 검사 + 실행 ===================== */
function parseInputs(){
  const yRaw = onlyDigits(elY.value).slice(0,4);
  const mRaw = onlyDigits(elM.value).slice(0,2);
  const dRaw = onlyDigits(elD.value).slice(0,2);

  if(yRaw.length !== 4) return { ok:false, msg:"연도(YYYY) 4자리를 입력해 주세요." };
  if(mRaw.length !== 2) return { ok:false, msg:"월(MM) 2자리를 입력해 주세요. (예: 04)" };
  if(dRaw.length !== 2) return { ok:false, msg:"일(DD) 2자리를 입력해 주세요. (예: 17)" };

  const y = parseInt(yRaw, 10);
  const m = parseInt(mRaw, 10);
  if(!(y >= 1900 && y <= 2026)) return { ok:false, msg:"연도는 1900~2026 범위로 입력해 주세요." };
  if(!(m >= 1 && m <= 12)) return { ok:false, msg:"월은 01~12 범위로 입력해 주세요." };

  const dim = daysInMonth(y, m);
  const d = parseInt(dRaw, 10);
  if(!(d >= 1 && d <= dim)) return { ok:false, msg:`일은 해당 월의 01~${String(dim).padStart(2,"0")} 범위로 입력해 주세요.` };

  elY.value = String(y);
  elM.value = String(m).padStart(2,"0");
  elD.value = String(d).padStart(2,"0");

  return { ok:true, y, m, d };
}

function showFortune(){
  setError("");
  const p = parseInputs();
  if(!p.ok){
    setError(p.msg);
    elOut.style.display = "none";
    return;
  }
  const data = buildFortune(p.y, p.m, p.d);
  elOut.style.display = "block";
  render(data);
}
</script>
</body>
</html>
